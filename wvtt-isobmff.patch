--- a/libavcodec/webvttdec.c
+++ b/libavcodec/webvttdec.c
@@ -28,6 +28,7 @@
 #include "avcodec.h"
 #include "ass.h"
 #include "codec_internal.h"
+#include "libavutil/intreadwrite.h"
 #include "libavutil/bprint.h"

 static const struct {
@@ -80,6 +81,54 @@
     return 0;
 }

+/* check if data looks like ISOBMFF wvtt (starts with vttc/vtte box) */
+static int is_isobmff_wvtt(const uint8_t *data, int size)
+{
+    uint32_t box_size, box_type;
+
+    if (size < 8)
+        return 0;
+
+    box_size = AV_RB32(data);
+    box_type = AV_RL32(data + 4);
+
+    if (box_size >= 8 && box_size <= size &&
+        (box_type == MKTAG('v', 't', 't', 'c') ||
+         box_type == MKTAG('v', 't', 't', 'e')))
+        return 1;
+
+    return 0;
+}
+
+/* extract text from wvtt sample (vttc/vtte box) */
+static int parse_isobmff_wvtt(const uint8_t *data, int size, AVBPrint *buf)
+{
+    uint32_t box_size, box_type;
+    const uint8_t *end = data + size;
+
+    if (size < 8)
+        return 0;
+
+    box_size = AV_RB32(data);
+    box_type = AV_RL32(data + 4);
+
+    if (box_type == MKTAG('v', 't', 't', 'e'))
+        return 0; /* empty cue */
+
+    if (box_type != MKTAG('v', 't', 't', 'c') || box_size < 8)
+        return AVERROR_INVALIDDATA;
+
+    data += 8;
+    while (data + 8 <= end) {
+        uint32_t child_size = AV_RB32(data);
+        uint32_t child_type = AV_RL32(data + 4);
+
+        if (child_size < 8 || data + child_size > end)
+            break;
+        if (child_type == MKTAG('p', 'a', 'y', 'l')) {
+            av_bprintf(buf, "%.*s", (int)(child_size - 8), data + 8);
+            return 0;
+        }
+        data += child_size;
+    }
+    return 0;
+}
+
 static int webvtt_decode_frame(AVCodecContext *avctx, AVSubtitle *sub,
                                int *got_sub_ptr, const AVPacket *avpkt)
 {
@@ -88,6 +137,24 @@
     FFASSDecoderContext *s = avctx->priv_data;
     AVBPrint buf;

+    /* handle ISOBMFF wvtt from MP4 */
+    if (ptr && avpkt->size > 0 &&
+        is_isobmff_wvtt((const uint8_t *)ptr, avpkt->size)) {
+        AVBPrint payload;
+        av_bprint_init(&payload, 0, AV_BPRINT_SIZE_UNLIMITED);
+        ret = parse_isobmff_wvtt((const uint8_t *)ptr, avpkt->size, &payload);
+        if (ret < 0) {
+            av_bprint_finalize(&payload, NULL);
+            return ret;
+        }
+        av_bprint_init(&buf, 0, AV_BPRINT_SIZE_UNLIMITED);
+        if (payload.len > 0 && !webvtt_event_to_ass(&buf, payload.str))
+            ret = ff_ass_add_rect(sub, buf.str, s->readorder++, 0, NULL, NULL);
+        av_bprint_finalize(&payload, NULL);
+        av_bprint_finalize(&buf, NULL);
+        *got_sub_ptr = sub->num_rects > 0;
+        return ret < 0 ? ret : avpkt->size;
+    }
+
     av_bprint_init(&buf, 0, AV_BPRINT_SIZE_UNLIMITED);
     if (ptr && avpkt->size > 0 && !webvtt_event_to_ass(&buf, ptr))
         ret = ff_ass_add_rect(sub, buf.str, s->readorder++, 0, NULL, NULL);
--- a/libavformat/isom.c
+++ b/libavformat/isom.c
@@ -76,6 +76,7 @@
     { AV_CODEC_ID_MOV_TEXT, MKTAG('t', 'e', 'x', 't') },
     { AV_CODEC_ID_MOV_TEXT, MKTAG('t', 'x', '3', 'g') },
     { AV_CODEC_ID_EIA_608,  MKTAG('c', '6', '0', '8') },
+    { AV_CODEC_ID_WEBVTT,   MKTAG('w', 'v', 't', 't') },
     { AV_CODEC_ID_NONE, 0 },
 };

--- a/libavformat/mov.c
+++ b/libavformat/mov.c
@@ -2655,14 +2655,33 @@
                                     AVStream *st, MOVStreamContext *sc,
                                     int64_t size)
 {
-    // ttxt stsd contains display flags, justification, background
-    // color, fonts, and default styles, so fake an atom to read it
-    MOVAtom fake_atom = { .size = size };
-    // mp4s contains a regular esds atom, dfxp ISMV TTML has no content
-    // in extradata unlike stpp MP4 TTML.
-    if (st->codecpar->codec_tag != AV_RL32("mp4s") &&
-        st->codecpar->codec_tag != MOV_ISMV_TTML_TAG)
-        mov_read_glbl(c, pb, fake_atom);
+    if (st->codecpar->codec_tag == MKTAG('w', 'v', 't', 't')) {
+        /* parse wvtt sample entry, look for vttC config box */
+        int64_t end = avio_tell(pb) + size;
+        while (avio_tell(pb) + 8 <= end) {
+            uint32_t box_size = avio_rb32(pb);
+            uint32_t box_type = avio_rl32(pb);
+
+            if (box_size < 8)
+                break;
+            if (box_type == MKTAG('v', 't', 't', 'C')) {
+                MOVAtom fake_atom = { .size = box_size - 8 };
+                mov_read_glbl(c, pb, fake_atom);
+                break;
+            }
+            avio_skip(pb, box_size - 8);
+        }
+    } else {
+        // ttxt stsd contains display flags, justification, background
+        // color, fonts, and default styles, so fake an atom to read it
+        MOVAtom fake_atom = { .size = size };
+        // mp4s contains a regular esds atom, dfxp ISMV TTML has no content
+        // in extradata unlike stpp MP4 TTML.
+        if (st->codecpar->codec_tag != AV_RL32("mp4s") &&
+            st->codecpar->codec_tag != MOV_ISMV_TTML_TAG)
+            mov_read_glbl(c, pb, fake_atom);
+    }
     st->codecpar->width  = sc->width;
     st->codecpar->height = sc->height;
 }
@@ -8571,6 +8590,7 @@
 { MKTAG('i','i','n','f'), mov_read_iinf },
 { MKTAG('a','m','v','e'), mov_read_amve }, /* ambient viewing environment box */
 { MKTAG('i','a','c','b'), mov_read_iacb },
+{ MKTAG('v','t','t','C'), mov_read_glbl },
 { 0, NULL }
 };

